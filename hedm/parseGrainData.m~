function log = parseGrainData(pfname, qsym, varargin)
% NEED TO CHECK THE COORDINATE TRANSFORMATION!!!!
% parseGrainData Parse the hedm grain file
%   In the case of ff-HEDM, input file is from MIDAS grains.csv file.
%
%   log = parseGrainData(pfname, qsym) reads the grain log file
%   with the name fileName and returns the information in an array of
%   structures with fields:
%       nExpGvec = Number of expected G vectors
%       nMeasGvec = Number of measured G vectors
%       nMeasOnce = Number of G vectors measured once
%       nMeasMore = Number of G vectors measured more than once
%       meanIA = Average internal angle between prediced and measured
%       U = 3x3 Orientation matrix
%       gvec = G vector table
%       hkl = 3 hkl values
% 
%   The columns of the log file are:
%       Sp_ID O[0][0] O[0][1] O[0][2] O[1][0] O[1][1] O[1][2] O[2][0] O[2][1] O[2][2] 
%       X Y Z a b c alpha beta gamma Err1 Err2 Err3 MeanRadius Confidence 
%       
%       where each row describes a grain
%       
%       O[row][col] is the orientation matrix of the grain that takes crystal frame to
%       sample frame in ESRF coordinate system. 
%       X,Y,Z define the center of mass coordinate of the grain in ESRF
%       coordinate system
%       a, b, c, alpha, beta, gamma are the crystal lattice
%       parameters of the grain (NEED TO DESCRIBE HOW THESE ARE DEFINED)
%       Err1, Err2, Err3
%       MeanRadius is the size of the grain
%       Confidence is the completeness of the grain (number of g-vectors
%       found / number of g-vectors anticipated)
%
%   In the case of nf-HEDM, input file is from Ice9 file postprocessed with
%   segmentation routine. This functionality was originally provided by
%   Dave Menasche at Carnegie Mellon University.
%
%   The columns of the input file are:
%       grain id
%       Center of mass (x = along beam, y = OB, z = up)
%       Average Orientation in Bunge convention that transformas a vector
%       in crystal frame to the laboratory frame
%       Volume 
%       AverageConfidence (bug in the segmentation routine) 
%       NumberNeighbors
%       IDsofNeighbors
%       MisorsWithNeighbors
%
%   INPUT:
%
%   pfname
%       full file path of the grain log file generated by ff-HEDM code
%
%   qsym 
%       Symmetry operators in quaternions
%
%   These arguments can be followed by a list of
%   parameter/value pairs. Options are:
%
%   'Technique'     far-field (ff) or near-field (nf). default is ff.
%   'CrdSystem'     coordinate system in the log file (default is APS)
%
%   OUTPUT:
%   
%   log
%       content of the grain log file organized into structure array
% 
%   Example:
%     log = parseGrainData(pfname);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% clear all
% close all
% clc

% pfname  = 'O:\li_march13\hedm_analysis_MultiRings_t150\Grains.csv';
% qsym    = CubSymmetries;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% default options
optcell = {...
    'Technique', 'ff', ...
    'CrdSystem', 'APS', ...
    };

% update option
opts    = OptArgs(optcell, varargin);

if strcmpi(opts.CrdSystem, 'APS')
    disp('COM / orientations will be converted to APS coordinate system')
elseif strcmpi(opts.CrdSystem, 'ESRF')
    disp('COM / orientations will be in ESRF coordinate system')
else
    disp('Unknown coordinate system')
    return
end

if strcmpi(opts.CrdSystem, 'APS')
    R_ESRF2APS  = RMatOfQuat(QuatOfESRF2APS);
else
    R_ESRF2APS  = eye(3,3);
end

if strcmpi(opts.Technique, 'ff')
    disp(sprintf('parsing ff-hedm data from %s', pfname));
    
    data    = load(pfname);
    nGrains = size(data, 1);
    
    % Loop over found grains
    log(nGrains) = struct(...
        'Quat',[],'R',[],'V',[],'Esam',[],'Ecry',[],'F',[], ...
        'lattprms',[], 'COM', [], 'ReflectionTable', [], 'Completeness', [], 'CrdSys', []);
    
    for i = 1:1:nGrains
        RMat    = reshape(data(i, 2:10), 3, 3)';
        COM     = data(i, 11:13);
        
        RMat    = R_ESRF2APS*RMat;
        COM     = R_ESRF2APS*COM';
        
        if strcmpi(opts.CrdSystem, 'APS')
            log(i).CrdSys   = 'APS';
        elseif strcmpi(opts.CrdSystem, 'ESRF')
            log(i).CrdSys   = 'ESRF';
        end
        Quat    = ToFundamentalRegionQ(QuatOfRMat(RMat), qsym);
        
        log(i).RMat = RMat;
        log(i).Quat = Quat;
        log(i).COM  = COM(:);
        
        %%%%%%% NEED TO CHECK THIS TO BE CONSISTENT WITH XSTAL CONVENTION
        log(i).lattprms     = data(i, 14:19);
        
        log(i).Error        = data(i, 20:22);
        log(i).MeanRadius   = data(i, 23);
        log(i).Completeness = data(i, 24);
    end
elseif strcmpi(opts.Technique, 'nf')
    disp(sprintf('parsing nf-hedm data from %s', pfname));
    
    fid = fopen(name);
    tline = fgetl(fid);
    counter = 1;
    
    while ischar(tline)
        data    = sscanf( tline , '%f', 10)';
        
        COM     = data(1,2:4);
        %%% THIS IS Bunge Angles GOING FROM LAB TO CRYSTAL
        BungeAngles = data(i,5:7);
        %%% CONVERTS BUNGE ANGLES TO ROT MATRIX THEN TRANSPOSE TO CHANGE
        %%% ITS MEANING TO "CRYSATL TO LAB"
        RMat    = RMatOfBunge(BungeAngles)';
        
        RMat    = R_ESRF2APS*RMat;
        COM     = R_ESRF2APS*COM';
        
        if strcmpi(opts.CrdSystem, 'APS')
            log(i).CrdSys   = 'APS';
        elseif strcmpi(opts.CrdSystem, 'ESRF')
            log(i).CrdSys   = 'ESRF';
        end
        
    end
    fclose(fid);
    for i = 1:1:nGrains
        
        
        
        
        
        
        
        Quat    = ToFundamentalRegionQ(QuatOfRMat(RMat), qsym);
        
        log(i).RMat = RMat;
        log(i).Quat = Quat;
        log(i).COM  = COM(:);
        
        log(i).Volume       = data(i,8);
        log(i).Confidence   = data(i,9);
        
        log(i).NumNeighbors     = data(i,10);
        log(i).IDofNeighbors    = data(i,11);
        
    end
    A = sscanf( tline , '%f', 10)';
    GM{1,counter} = A(1);
    GM{2,counter} = A(2:4);
    GM{3,counter} = A(5:7);
    GM{4,counter} = A(8);
    GM{5,counter} = A(9);
    GM{6,counter} = A(10);
    B = sscanf(tline,'%f',10+2*A(10) );
    GM{7,counter} = B(11:11+A(10)-1);
    GM{8,counter} = B(11+A(10):end);
    tline = fgetl(fid);
    counter = counter+1;
end